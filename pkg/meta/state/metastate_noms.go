package state

import (
	"fmt"
	"reflect"

	"github.com/attic-labs/noms/go/marshal"
	nt "github.com/attic-labs/noms/go/types"
	util "github.com/oneiro-ndev/noms-util"
	"github.com/pkg/errors"
)

// this code generated by github.com/oneiro-ndev/generator/cmd/nomsify
// it was edited and moved to a new file in order that regenerating will cause
// compilation errors, so that humans can appropriately edit the generated code.
// search for "WARNING WARNING" to find the appropriate section.

var metastateStructTemplate nt.StructTemplate

func init() {
	metastateStructTemplate = nt.MakeStructTemplate("Metastate", []string{
		"ChildState",
		"Height",
		"Stats",
		"Validators",
	})
}

// MarshalNoms implements noms/go/marshal.Marshaler
func (x Metastate) MarshalNoms(vrw nt.ValueReadWriter) (metastateValue nt.Value, err error) {
	// x.Validators (map[string]int64->*ast.MapType) is primitive: false

	// template decompose: x.Validators (map[string]int64->*ast.MapType)
	// template map: x.Validators
	validatorsKVs := make([]nt.Value, 0, len(x.Validators)*2)
	for validatorsKey, validatorsValue := range x.Validators {

		// template decompose: validatorsValue (int64->*ast.Ident)

		validatorsKVs = append(
			validatorsKVs,
			nt.String(validatorsKey),
			util.Int(validatorsValue).NomsValue(),
		)
	}

	// x.Height (uint64->*ast.Ident) is primitive: true

	// x.Stats (VoteStats->*ast.Ident) is primitive: false

	// template decompose: x.Stats (VoteStats->*ast.Ident)
	// template nomsmarshaler: x.Stats
	statsValue, err := x.Stats.MarshalNoms(vrw)
	if err != nil {
		return nil, errors.Wrap(err, "Metastate.MarshalNoms->Stats.MarshalNoms")
	}

	// x.ChildState (State->*ast.Ident) is primitive: false

	// template decompose: x.ChildState (State->*ast.Ident)
	// template nomsmarshaler: x.ChildState
	childStateValue, err := x.ChildState.MarshalNoms(vrw)
	if err != nil {
		return nil, errors.Wrap(err, "Metastate.MarshalNoms->ChildState.MarshalNoms")
	}

	return metastateStructTemplate.NewStruct([]nt.Value{
		// x.ChildState (State)
		childStateValue,
		// x.Height (uint64)

		util.Int(x.Height).NomsValue(),
		// x.Stats (VoteStats)
		statsValue,
		// x.Validators (map[string]int64)

		nt.NewMap(vrw, validatorsKVs...),
	}), nil
}

var _ marshal.Marshaler = (*Metastate)(nil)

// UnmarshalNoms implements noms/go/marshal.Unmarshaler
//
// This method makes no attempt to zeroize the provided struct; it simply
// overwrites fields as they are found.
func (x *Metastate) UnmarshalNoms(value nt.Value) (err error) {
	vs, ok := value.(nt.Struct)
	if !ok {
		return fmt.Errorf(
			"Metastate.UnmarshalNoms expected a nt.Value; found %s",
			reflect.TypeOf(value),
		)
	}

	// noms Struct.MaybeGet isn't efficient: it iterates over all fields of
	// the struct until it finds one whose name happens to match the one sought.
	// It's better to iterate once over the struct and set the fields of the
	// target struct in arbitrary order.
	vs.IterFields(func(name string, value nt.Value) {
		if err == nil {
			switch name {
			// x.Validators (map[string]int64->*ast.MapType) is primitive: false
			case "Validators":
				// template u_decompose: x.Validators (map[string]int64->*ast.MapType)
				// template u_map: x.Validators
				if validatorsMap, ok := value.(nt.Map); ok {
					x.Validators = make(map[string]int64)
					validatorsMap.Iter(func(validatorsKey, validatorsValue nt.Value) (stop bool) {
						validatorsKeyString, ok := validatorsKey.(nt.String)
						if !ok {
							err = fmt.Errorf(
								"Metastate.UnmarshalNoms expected validatorsKey to be a nt.String; found %s",
								reflect.TypeOf(validatorsKey),
							)
							return true
						}

						// template u_decompose: validatorsValue (int64->*ast.Ident)
						// template u_primitive: validatorsValue
						var validatorsValueValue util.Int
						validatorsValueValue, err = util.IntFrom(validatorsValue)
						if err != nil {
							err = errors.Wrap(err, "Metastate.UnmarshalNoms->validatorsValue")
							return
						}
						validatorsValueTyped := int64(validatorsValueValue)
						if err != nil {
							return true
						}
						x.Validators[string(validatorsKeyString)] = validatorsValueTyped
						return false
					})
				} else {
					err = fmt.Errorf(
						"Metastate.UnmarshalNoms expected x.Validators to be a nt.Map; found %s",
						reflect.TypeOf(value),
					)
				}

			// x.Height (uint64->*ast.Ident) is primitive: true
			case "Height":
				// template u_decompose: x.Height (uint64->*ast.Ident)
				// template u_primitive: x.Height
				var heightValue util.Int
				heightValue, err = util.IntFrom(value)
				if err != nil {
					err = errors.Wrap(err, "Metastate.UnmarshalNoms->Height")
					return
				}
				heightTyped := uint64(heightValue)

				x.Height = heightTyped

			// x.Stats (VoteStats->*ast.Ident) is primitive: false
			case "Stats":
				// template u_decompose: x.Stats (VoteStats->*ast.Ident)
				// template u_nomsmarshaler: x.Stats
				var statsInstance VoteStats
				err = statsInstance.UnmarshalNoms(value)
				err = errors.Wrap(err, "Metastate.UnmarshalNoms->Stats")

				x.Stats = statsInstance

			// x.ChildState (State->*ast.Ident) is primitive: false
			case "ChildState":
				// template u_decompose: x.ChildState (State->*ast.Ident)
				// template u_nomsmarshaler: x.ChildState

				// WARNING WARNING WARNING WARNING WARNING WARNING WARNING
				// this code is hand-edited: we have as a precondition that
				// x.ChildState is a non-nil instance of the State interface;
				// this is mandatory to get this unmarshaller to work.
				//
				// In general, when not dealing with interfaces, the generated
				// code will work fine, but we can't rely on that right now.
				err = x.ChildState.UnmarshalNoms(value)
				err = errors.Wrap(err, "Metastate.UnmarshalNoms->ChildState")
			}
		}
	})
	return
}

var _ marshal.Unmarshaler = (*Metastate)(nil)
